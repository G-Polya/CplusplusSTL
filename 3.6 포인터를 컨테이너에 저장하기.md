# 3.6 포인터를 컨테이너에 저장하기
- 컨테이너에 객체보단 포인터를 저장하는것이 더 좋고, 원시포인터보단 스마트 포인터가 대부분은 더 좋다.
```C++
vector<unique_ptr<string>> words;
words.push_back(make_unique<string>("one"));
words.push_back(make_unique<string>("two"));
```


## 3.6.1 순차열 컨테이너에 포인터 저장하기
- 컨테이너에 원시 포인터를 저장할 때 발생하는 문제를 방지하기 위해 스마트포인터를 사용한다
```C++
vector<string> words;
string word;
cout<<"Enter words separated by spaces, enter Ctrl+Z on a separate line to end:\n";
while(true)
{
    if((cin>>word).eof())
    {
        cin.clear();
        break;
    }
    words.push_back(new string(word));      // 객체를 생성하고 주소를 저장한다. 
}

// 객체의 주소가 저장된 words 벡터의 내용을 출력하려면 다음과 같이 작성해야한다
for(auto& w : words)
    cout << w << " ";
cout<<endl;

// 컨테이너 원소에 접근하려고 반복자를 사용하고 싶다면 문자열을 출력하는 코드는 다음과 같다
for (auto iter = begin(words); iter != end(words); iter++)
    cout<<**iter<<" ";      
cout<<endl; 
// iter는 반복자이고, iter가 가리키는 원소에 접근하려면 반드시 역참조를 해야한다. 원소도 포인터라서 string객체를 얻으려면 이것도 역참조를 해야한다. 따라서 string객체를 얻는 표현식은 **iter가 된다.
```
- 포인터 원소를 삭제할 때는 자유 공간에 있는 메모리를 먼저 해제해야하고, 이를 직접 관리해야한다.
- 자유 공간에 있는 메모리를 해제하지 않고 삭제하면 메모리를 해제할 수 없게 되고 이는 흔히 발생하는 메모리 누수 유형이다. 다음은 words벡터에서 메모리 누수가 발생하는 코드이다.
```C++
for(auto iter = begin(words); iter != end(words); iter++)
{
    if(**iter == "one")
        words.erase(iter);      // 메모리 누수!
    else
        **iter;
}
```
- 포인터를 삭제하지만, 포인터가 가리키는 메모리는 해제하지 않아서 메모리 누수가 발생한 것이다. 원시 포인터를 저장한 원소를 삭제할 때는 메모리를 먼저 해제해야 한다.
```C++
for(auto iter = begin(words); iter != end(begin); iter++)
{
    if(**iter == "one")
    {
        delete *iter;           // 메모리를 해제한다...
        words.erase(iter);      // ...그리고 포인터를 삭제한다
    }
    else
        **iter;
}

// vector를 제거하기 전에 자유공간에서 string 객체를 모두 삭제해야 한다는 점을 잊지말자. 다음과 같은 순서로 삭제해야 한다
for(auto& w : words)
    delete w;
words.clear();
```
- 인덱스를 사용해 포인터에 접근한다면 간단히 delete 연산자를 사용해 string 객체를 삭제하면 된다. 루프가 끝나면 vector에 있는 모든 원소는 invalid 포인터가 된다.
- 따라서 vector를 이런 상태로 남겨두지 않아야 하고 clear()를 호출해서 모든 원소를 제거한다.
---
- 컨테이너에 스마트 포인터를 저장한다면 자유 공간에서 메모리를 해제하는 걸 걱정하지 않아도 된다
```C++
cout<<"Enter words separated by spaces, enter Ctrl+Z on a separate line to end:\n";
while(true)
{
    if((cin>>word).eof())
    {
        cin.clear();
        break;
    }
    words.push_back(make_shared<string>(word));   // string에 대한 스마트 포인터를 생성하고 저장
}
